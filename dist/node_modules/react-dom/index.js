(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, (global.index = global.index || {}, global.index.js = factory()));
})(this, (function () { 'use strict';

  const FunctionComponent = 0;
  const HostRoot = 3;
  const HostComponent = 5;
  const HostText = 6;

  const NoFlags = 0b00000001; // 没有标记
  const Placement = 0b00000010; // 插入标记
  const Update = 0b00000100; // 更新标记
  const ChildDeletion = 0b00001000; // 子节点删除标记
  const Ref = 0b0010000;
  const Visibility = 0b0100000;
  const MutationMask = Placement | Update | ChildDeletion | Ref | Visibility;

  class FiberNode {
      tag; // Fiber的类型
      key; // 唯一标识符
      type; // 元素类型
      ref; // 引用
      stateNode; // 关联的DOM节点或组件实例
      pengingProps; // 待处理的属性
      return; // 指向父Fiber节点
      sibling; // 指向兄弟Fiber节点
      child; // 指向子Fiber节点
      index; // 在兄弟节点中的索引
      memoizedProps; // 已处理的属性
      memoiszedState; // 已处理的状态
      alternate; // 用于在workinProgess与current两棵缓存树中进行切换
      flags; // 用于标记Fiber的状态，如更新、删除等
      subtreeFlags; // 子树的标记，用于标记子节点的状态
      updateQueue; // 更新队列，用于存储待处理的更新
      constructor(tag, pengingProps, key) {
          this.tag = tag; // Fiber的类型
          this.key = key; // 唯一标识符  
          this.type = null; // 元素类型   
          //树状结构
          this.return = null; // 指向父Fiber节点
          this.sibling = null; // 指向兄弟Fiber节点
          this.child = null; // 指向子Fiber节点
          this.index = 0; // 在兄弟节点中的索引
          this.ref = null; // 引用
          //作为工作单元
          this.pengingProps = pengingProps; // 待处理的属性
          this.memoizedProps = null; // 已处理的属性
          this.memoiszedState = null; // 已处理的状态
          this.updateQueue = null; // 更新队列，用于存储待处理的更新
          this.alternate = null; // 用于在workinProgess与current两棵缓存树中进行切换
          //副作用
          this.flags = NoFlags; //用于标记Fiber的状态，如更新、删除等
          this.subtreeFlags = NoFlags; // 子树的标记，用于标记子节点的状态
      }
  }
  class FiberRootNode {
      container; // 容器信息
      current; // 当前的Fiber节点
      finishedWork; // 完成的Fiber节点
      constructor(container, hostRootFiber) {
          this.container = container; // 容器信息
          this.current = hostRootFiber; // 当前的Fiber节点
          hostRootFiber.stateNode = this;
          this.finishedWork = null; // 完成的Fiber节点，初始为null
      }
  }
  const createWorkInProgress = (current, pendingProps) => {
      let wip = current.alternate; // 获取当前Fiber节点的备用节点
      if (wip === null) {
          //mount
          wip = new FiberNode(current.tag, pendingProps, current.key); // 如果备用节点不存在，创建一个新的Fiber节点
          wip.type = current.type; // 设置备用节点的类型
          wip.stateNode = current.stateNode; // 关联状态节点
          wip.alternate = current; // 设置备用节点的alternate指向当前节点
          current.alternate = wip; // 设置当前节点的alternate指向备用节点
      }
      else {
          //update
          wip.pengingProps = pendingProps; // 更新备用节点的待处理属性
          wip.flags = NoFlags; // 重置备用节点的标记
      }
      wip.type = current.type; // 确保备用节点的类型与当前节点一致
      wip.updateQueue = current.updateQueue; // 继承当前节点的更新队列
      wip.child = current.child; // 继承当前节点的子节点
      wip.memoizedProps = current.memoizedProps; // 继承当前节点的已处理属性
      wip.memoiszedState = current.memoiszedState; // 继承当前
      return wip; // 返回备用节点
  };
  const createFiberFromElement = (element) => {
      const { type, key, props } = element; // 解构React元素的类型、键和属性
      let fiberTag = FunctionComponent;
      if (typeof type === 'string') {
          fiberTag = HostComponent; // 如果类型是字符串，设置为HostComponent 
      }
      else if (typeof type === 'function' && true) {
          console.warn('createFiberFromElement未实现的类型');
      }
      const fiber = new FiberNode(fiberTag, props, key); // 创建新的Fiber节点
      fiber.type = type; // 设置Fiber节点的类型
      return fiber; // 返回创建的Fiber节点
  };

  const createUpdate = (action) => {
      return {
          action,
      };
  };
  const createUpdateQueue = () => {
      return {
          shared: {
              pending: null, // 初始化时没有待处理的更新
          },
      };
  };
  const enqueueUpdate = (updateQueue, update) => {
      updateQueue.shared.pending = update; // 将更新添加到待处理队列中
  };
  const processUpdateQueue = (baseState, pendingUpdate) => {
      const result = { memoizedState: baseState }; // 初始化结果为基础状态
      if (pendingUpdate !== null) {
          const action = pendingUpdate.action;
          if (action instanceof Function) {
              result.memoizedState = action(baseState); // 如果action是函数，执行它并更新状态
          }
          else {
              result.memoizedState = action; // 否则直接使用action作为新的状态
          }
      }
      return result;
  };

  // export const createIns÷tance = (type: string,props: any): Instance => {
  const createInstance = (type) => {
      const element = document.createElement(type); // 创建一个新的DOM元素
      return element; // 返回创建的DOM元素
  };
  const appendInitialChild = (parent, child) => {
      parent.appendChild(child); // 将子元素添加到父元素中
  };

  const completeWork = (wip) => {
      //递归中的归
      const newProps = wip.pengingProps; // 获取待处理的属性
      const current = wip.alternate; // 获取当前的备用节点
      switch (wip.tag) {
          case HostComponent:
              if (current !== null && wip.stateNode) ;
              else {
                  //1.构建DOM
                  const instance = createInstance(wip.type);
                  //2.将DOM插入到DOM树中
                  appendAllChildren(instance, wip); // 将子节点添加到实例中
                  wip.stateNode = instance; // 将实例赋值给wip的stateNode
              }
              bubbleProperties(wip); // 处理子节点的属性
              return null;
          case HostText:
              if (current !== null && wip.stateNode) ;
              else {
                  //构建DOM
                  const instance = createInstance(newProps.content);
                  wip.stateNode = instance; // 将实例赋值给wip的stateNode
              }
              bubbleProperties(wip); // 处理子节点的属性
              return null;
          case HostRoot:
              bubbleProperties(wip);
              return null;
          default:
              {
                  console.warn('未处理的workTag类型', wip.tag);
              }
              break;
      }
  };
  function appendAllChildren(parent, wip) {
      let node = wip.child;
      while (node !== null) {
          if (node.tag === HostComponent || node.tag === HostText) {
              appendInitialChild(parent, node?.stateNode);
          }
          else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
          }
          if (node === wip) {
              return;
          }
          while (node.sibling === null) {
              if (node.return === null || node.return === wip) {
                  return;
              }
              node = node?.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
      }
  }
  function bubbleProperties(wip) {
      let subtreeFlags = NoFlags;
      let child = wip.child;
      while (child !== null) {
          subtreeFlags |= child.subtreeFlags;
          subtreeFlags |= child.flags;
          child.return = wip;
          child = child.sibling;
      }
      wip.subtreeFlags |= subtreeFlags;
  }

  const supportSymbol = typeof Symbol === 'function' && Symbol.for; //判断宿主环境是否支持Symbol
  const REACT_ELEMENT_TYPE = supportSymbol
      ? Symbol.for('react.element')
      : 0xeac7; //react元素类型

  function ChildReconciler(shouldTrackSideEffects) {
      function reconcileSingleElement(returnFiber, currentFiber, element) {
          const fiber = createFiberFromElement(element); // 创建新的Fiber节点
          fiber.return = returnFiber; // 设置父节点
          return fiber; // 返回新的Fiber节点
      }
      function reconcileSingleTextNode(returnFiber, currentFiber, content) {
          const fiber = new FiberNode(HostText, { content }, null); // 创建文本节点的Fiber节点
          fiber.return = returnFiber; // 设置父节点
          return fiber; // 返回新的Fiber节点
      }
      function placeSingleChild(fiber) {
          if (shouldTrackSideEffects && fiber.alternate === null) {
              fiber.flags |= Placement; // 标记为需要插入
          }
          return fiber; // 返回单个子节点的Fiber节点
      }
      return function reconcileChildFibers(returnFiber, currentFiber, newChild) {
          if (typeof newChild === 'object' && typeof newChild !== null) {
              switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                      return placeSingleChild(reconcileSingleElement(returnFiber, currentFiber, newChild));
                  default:
                      {
                          console.warn('reconcileChildFibers未实现的类型');
                      }
                      break;
              }
          }
          //多节点的情况
          //HostRoot
          if (typeof newChild === 'string' || typeof newChild === 'number') {
              return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFiber, newChild));
          }
          return null;
      };
  }
  const reconcileChildFibers = ChildReconciler(true); // 默认开启副作用跟踪
  const mountChildFibers = ChildReconciler(false); // 默认开启副作用跟踪

  //递归中的递阶段
  const beginWork = (wip) => {
      //比较，返回子fiberNode
      switch (wip.tag) {
          case HostRoot:
              return updateHostRoot(wip); // 更新根节点
          case HostComponent:
              return updateHostComponent(wip); // 更新组件节点
          case HostText:
              return null;
          default:
              {
                  console.warn('beginWork未实现的类型');
              }
              break;
      }
      return null;
  };
  function updateHostRoot(wip) {
      const baseState = wip.memoizedProps; // 获取基础状态
      const updateQueue = wip.updateQueue; // 获取更新队列
      const pending = updateQueue.shared.pending; // 获取待处理的更新
      updateQueue.shared.pending = null; // 清空待处理的更新
      const { memoizedState } = processUpdateQueue(baseState, pending); // 处理更新队列
      wip.memoiszedState = memoizedState; // 更新已处理状态
      const nextChildren = wip.memoiszedState; // 获取待处理的子节点
      reconileChildren(wip, nextChildren); // 递归处理子节点
      return wip.child; // 返回子节点
  }
  function updateHostComponent(wip) {
      const nextProps = wip.pengingProps; // 获取待处理的属性
      const nextChildren = nextProps.children; // 获取待处理的属性
      reconileChildren(wip, nextChildren); // 递归处理子节点
      return wip.child; // 返回子节点
  }
  function reconileChildren(wip, children) {
      const current = wip.alternate; // 获取备用节点
      if (current !== null) {
          //update
          wip.child = reconcileChildFibers(wip, current?.child, children); // 更新子节点
      }
      else {
          wip.child = mountChildFibers(wip, null, children); // 创建新的子节点
      }
  }

  let workInProgress = null;
  function prepareRefreshStack(root) {
      workInProgress = createWorkInProgress(root.current, {}); // 设置当前工作中的Fiber节点
  }
  function scheduleUpdateOnFiber(fiber) {
      //调度功能
      const root = markUpdateFromFiberToRoot(fiber); // 标记从Fiber节点到根节点的更新
      renderRoot(root); // 渲染根节点
  }
  function markUpdateFromFiberToRoot(fiber) {
      let node = fiber;
      let parent = fiber.return; // 获取父节点
      while (parent !== null) {
          node = parent; // 向上回溯到根节点
          parent = parent.return; // 获取父节点
      }
      if (node.tag === HostRoot) { // 如果根节点是HostRoot类型
          return node.stateNode; // 返回根节点的状态节点
      }
      return null; // 如果没有找到根节点，返回null
  }
  function renderRoot(root) {
      prepareRefreshStack(root);
      do {
          try {
              workLoop();
              break; // 如果工作循环完成，跳出循环
          }
          catch (error) {
              // 处理错误逻辑，例如记录错误或重置工作状态
              {
                  console.error('workLoop发生错误:', error);
              }
              workInProgress = null; // 重置当前工作中的Fiber节点
          }
      } while (true);
      const finishedWork = root.current.alternate;
      root.finishedWork = finishedWork; // 设置完成的工作节点
      commitRoot(root); // 提交根节点
  }
  function commitRoot(root) {
      const finishedWork = root.finishedWork; // 获取完成的工作节点
      if (finishedWork === null) {
          return; // 如果没有完成的工作节点，直接返回
      }
      {
          console.warn('commit阶段开始', finishedWork);
      }
      //重置
      root.finishedWork = null;
      //判断是否存在3个子阶段需要执行的操作
      const subtreeFlags = (finishedWork.subtreeFlags & (MutationMask)) !== NoFlags; // 检查子树标记是否包含变更标记
      const rootHasEffect = (finishedWork.flags & (MutationMask)) !== NoFlags; // 检查根节点是否有副作用标记
      if (subtreeFlags || rootHasEffect) {
          //beforeMutation
          //mutation Placement
          root.current = finishedWork; // 更新当前节点为完成的工作节点
          //layout
      }
      else {
          root.current = finishedWork;
      }
  }
  function workLoop() {
      while (workInProgress !== null) {
          // 执行工作单元
          performUnitOfWork(workInProgress);
      }
  }
  function performUnitOfWork(fiber) {
      const next = beginWork(fiber);
      fiber.memoizedProps = fiber.pengingProps; // 将待处理的属性设置为已处理的属性
      if (next === null) {
          completeUnitOfWork(fiber); // 如果没有下一个工作单元，完成当前工作单元
      }
      else {
          workInProgress = next; // 设置下一个工作单元为当前工作中的Fiber节点
      }
  }
  function completeUnitOfWork(fiber) {
      let node = fiber;
      do {
          completeWork(node); // 完成当前工作单元
          const sibling = node.sibling; // 获取兄弟节点
          if (sibling !== null) {
              workInProgress = sibling; // 如果有兄弟节点，设置为当前工作中的Fiber节点
              return; // 结束当前工作单元的处理
          }
          node = node.return; // 向上回溯到父节点
          workInProgress = node; // 更新当前工作中的Fiber节点
      } while (node !== null);
  }

  function createContainer(container) {
      const hostRootFiber = new FiberNode(HostRoot, {}, null); // 创建根Fiber节点
      const root = new FiberRootNode(container, hostRootFiber); // 创建Fiber根节点
      hostRootFiber.updateQueue = createUpdateQueue(); // 初始化更新队列
      return root;
  }
  function updateContainer(element, root) {
      const hostRootFiber = root.current; // 获取当前的根Fiber节点
      const update = createUpdate(element); // 创建更新
      enqueueUpdate((hostRootFiber.updateQueue), update); // 将更新添加到更新队列
      scheduleUpdateOnFiber(hostRootFiber); // 调度更新
      return element; // 返回更新的元素
  }

  function createRoot(container) {
      const root = createContainer(container); // 创建根容器
      return {
          render(element) {
              updateContainer(element, root); // 更新容器中的内容
          }
      };
  }

  var ReactDOM = /*#__PURE__*/Object.freeze({
    __proto__: null,
    createRoot: createRoot
  });

  return ReactDOM;

}));
