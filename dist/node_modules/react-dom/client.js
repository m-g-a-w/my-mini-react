(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react')) :
  typeof define === 'function' && define.amd ? define(['react'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.client = factory(global.React));
})(this, (function (React) { 'use strict';

  function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    }
    n.default = e;
    return Object.freeze(n);
  }

  var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);

  const FunctionComponent = 0;
  const HostRoot = 3;
  const HostComponent = 5;
  const HostText = 6;
  const Fragment = 7;

  const NoFlags = 0b00000000; // 没有标记
  const Placement = 0b00000001; // 插入标记
  const Update = 0b00000010; // 更新标记
  const ChildDeletion = 0b00000100; // 子节点删除标记
  const Ref = 0b000000;
  const Visibility = 0b0100000;
  const MutationMask = Placement | Update | ChildDeletion | Ref | Visibility;

  class FiberNode {
      tag; // Fiber的类型
      key; // 唯一标识符
      type; // 元素类型
      ref; // 引用
      stateNode; // 关联的DOM节点或组件实例
      pengingProps; // 待处理的属性
      return; // 指向父Fiber节点
      sibling; // 指向兄弟Fiber节点
      child; // 指向子Fiber节点
      index; // 在兄弟节点中的索引
      memoizedProps; // 已处理的属性
      memoizedState; // 已处理的状态
      alternate; // 用于在workinProgess与current两棵缓存树中进行切换
      flags; // 用于标记Fiber的状态，如更新、删除等
      subtreeFlags; // 子树的标记，用于标记子节点的状态
      updateQueue; // 更新队列，用于存储待处理的更新
      deletions;
      constructor(tag, pengingProps, key) {
          this.tag = tag; // Fiber的类型
          this.key = key; // 唯一标识符  
          this.type = null; // 元素类型   
          //树状结构
          this.return = null; // 指向父Fiber节点
          this.sibling = null; // 指向兄弟Fiber节点
          this.child = null; // 指向子Fiber节点
          this.index = 0; // 在兄弟节点中的索引
          this.ref = null; // 引用
          //作为工作单元
          this.pengingProps = pengingProps; // 待处理的属性
          this.memoizedProps = null; // 已处理的属性
          this.memoizedState = null; // 已处理的状态
          this.updateQueue = null; // 更新队列，用于存储待处理的更新
          this.alternate = null; // 用于在workinProgess与current两棵缓存树中进行切换
          //副作用
          this.flags = NoFlags; //用于标记Fiber的状态，如更新、删除等
          this.subtreeFlags = NoFlags; // 子树的标记，用于标记子节点的状态
          this.deletions = null;
      }
  }
  class FiberRootNode {
      container; // 容器信息
      current; // 当前的Fiber节点
      finishedWork; // 完成的Fiber节点
      constructor(container, hostRootFiber) {
          this.container = container; // 容器信息
          this.current = hostRootFiber; // 当前的Fiber节点
          hostRootFiber.stateNode = this;
          this.finishedWork = null; // 完成的Fiber节点，初始为null
      }
  }
  const createWorkInProgress = (current, pendingProps) => {
      let wip = current.alternate; // 获取当前Fiber节点的备用节点
      if (wip === null) {
          //mount
          wip = new FiberNode(current.tag, pendingProps, current.key); // 如果备用节点不存在，创建一个新的Fiber节点
          wip.type = current.type; // 设置备用节点的类型
          wip.stateNode = current.stateNode; // 关联状态节点
          wip.alternate = current; // 设置备用节点的alternate指向当前节点
          current.alternate = wip; // 设置当前节点的alternate指向备用节点
      }
      else {
          //update
          wip.pengingProps = pendingProps; // 更新备用节点的待处理属性
          wip.flags = NoFlags; // 重置备用节点的标记
          wip.subtreeFlags = NoFlags;
          wip.deletions = null;
      }
      wip.type = current.type; // 确保备用节点的类型与当前节点一致
      wip.updateQueue = current.updateQueue; // 继承当前节点的更新队列
      wip.child = current.child; // 继承当前节点的子节点
      wip.memoizedProps = current.memoizedProps; // 继承当前节点的已处理属性
      wip.memoizedState = current.memoizedState; // 继承当前
      return wip; // 返回备用节点
  };
  const createFiberFromElement = (element) => {
      const { type, key, props } = element; // 解构React元素的类型、键和属性
      let fiberTag = FunctionComponent;
      if (typeof type === 'string') {
          fiberTag = HostComponent; // 如果类型是字符串，设置为HostComponent 
      }
      else if (typeof type === 'function' && true) {
          console.warn('createFiberFromElement未实现的类型');
      }
      const fiber = new FiberNode(fiberTag, props, key); // 创建新的Fiber节点
      fiber.type = type; // 设置Fiber节点的类型
      return fiber; // 返回创建的Fiber节点
  };
  const createFiberFromFragment = (elements, key) => {
      const fiber = new FiberNode(Fragment, elements, key);
      fiber.type = Fragment;
      return fiber;
  };

  const createUpdate = (action) => {
      return {
          action,
      };
  };
  const createUpdateQueue = () => {
      return {
          shared: {
              pending: null, // 初始化时没有待处理的更新
          },
          dispatch: null
      };
  };
  const enqueueUpdate = (updateQueue, update) => {
      updateQueue.shared.pending = update; // 将更新添加到待处理队列中
  };
  const processUpdateQueue = (baseState, pendingUpdate) => {
      const result = { memoizedState: baseState }; // 初始化结果为基础状态
      if (pendingUpdate !== null) {
          const action = pendingUpdate.action;
          if (action instanceof Function) {
              result.memoizedState = action(baseState); // 如果action是函数，执行它并更新状态
          }
          else {
              result.memoizedState = action; // 否则直接使用action作为新的状态
          }
      }
      return result;
  };

  const validateEventTypeList = ['click'];
  const elementPropsKey = '__props';
  function updateFiberProps(node, props) {
      node[elementPropsKey] = props;
  }
  function initEvent(container, eventType) {
      if (!validateEventTypeList.includes(eventType)) {
          console.warn("当前不支持的事件类型", eventType);
          return;
      }
      {
          console.log("初始化事件", eventType);
      }
      container.addEventListener(eventType, (e) => {
          dispatchEvent(container, eventType, e);
      });
  }
  function createSyntheticEvent(event) {
      const syntheticEvent = event;
      syntheticEvent.__stopPropagation = false;
      const originalStopPropagation = event.stopPropagation;
      syntheticEvent.stopPropagation = () => {
          syntheticEvent.__stopPropagation = true;
          if (originalStopPropagation) {
              originalStopPropagation();
          }
      };
      return syntheticEvent;
  }
  function dispatchEvent(container, eventType, event) {
      const targetElement = event.target;
      if (targetElement === null) {
          console.warn("事件不存在target", event);
          return;
      }
      //1.获取事件
      const { bubble, capture } = collectPaths(targetElement, container, eventType);
      //2.构造合成时间
      const se = createSyntheticEvent(event);
      //3.遍历capture
      triggerEventFolw(capture, se);
      if (!se.__stopPropagation) {
          //4.遍历bubble
          triggerEventFolw(bubble, se);
      }
  }
  function getEventCallbackNameFromEventType(eventType) {
      return {
          click: ['onClickCapture', 'onClick']
      }[eventType];
  }
  function triggerEventFolw(path, se) {
      for (let i = 0; i < path.length; i++) {
          const callback = path[i];
          callback.call(null, se);
          if (se.__stopPropagation) {
              break; //阻止事件继续传播
          }
      }
  }
  function collectPaths(targetElement, container, eventType) {
      const paths = {
          capture: [],
          bubble: []
      };
      while (targetElement && targetElement !== container) {
          const elementProps = targetElement[elementPropsKey];
          if (elementProps) {
              //click
              const callbackNameList = getEventCallbackNameFromEventType(eventType);
              if (callbackNameList) {
                  callbackNameList.forEach((callbackName, i) => {
                      const eventCallback = elementProps[callbackName];
                      if (eventCallback) {
                          if (i === 0) {
                              paths.capture.unshift(eventCallback);
                          }
                          else {
                              paths.bubble.push(eventCallback);
                          }
                      }
                  });
              }
          }
          targetElement = targetElement.parentNode;
      }
      return paths;
  }

  // export const createIns÷tance = (type: string,props: any): Instance => {
  const createInstance = (type, props) => {
      const element = document.createElement(type); // 创建一个新的DOM元素
      updateFiberProps(element, props);
      return element; // 返回创建的DOM元素
  };
  const appendInitialChild = (parent, child) => {
      parent.appendChild(child); // 将子元素添加到父元素中
  };
  const createTextInstance = (content) => {
      return document.createTextNode(content); // 创建一个文本节点
  };
  const appendChildToContainer = appendInitialChild;
  const commitUpdate = (fiber) => {
      switch (fiber.tag) {
          case HostText:
              const text = fiber.memoizedProps.content;
              return commitTextUpdate(fiber.stateNode, text);
          case HostComponent:
              return updateFiberProps(fiber.stateNode, fiber.memoizedProps);
          default:
              {
                  console.warn("未实现的update类型");
              }
              return;
      }
  };
  function commitTextUpdate(textInstance, content) {
      textInstance.textContent = content;
  }
  const removeChild = (child, container) => {
      if (child && container) {
          container.removeChild(child);
      }
  };

  function markUpdate(wip) {
      wip.flags |= Update;
  }
  const completeWork = (wip) => {
      //递归中的归
      const newProps = wip.pengingProps; // 获取待处理的属性
      const current = wip.alternate; // 获取当前的备用节点
      switch (wip.tag) {
          case HostComponent:
              if (current !== null && wip.stateNode) {
                  //update
                  //判断props是否变化
                  //如果变化则添加update tag
                  updateFiberProps(wip.stateNode, newProps);
              }
              else {
                  //1.构建DOM
                  const instance = createInstance(wip.type, newProps);
                  //2.将DOM插入到DOM树中
                  appendAllChildren(instance, wip); // 将子节点添加到实例中
                  wip.stateNode = instance; // 将实例赋值给wip的stateNode
              }
              bubbleProperties(wip); // 处理子节点的属性
              return null;
          case HostText:
              if (current !== null && wip.stateNode) {
                  //update
                  const oldText = current.memoizedProps.content;
                  const newText = newProps.content;
                  if (oldText !== newText) {
                      markUpdate(wip);
                  }
              }
              else {
                  //构建DOM
                  const instance = createTextInstance(newProps.content);
                  wip.stateNode = instance; // 将实例赋值给wip的stateNode
              }
              bubbleProperties(wip); // 处理子节点的属性
              return null;
          case HostRoot:
              bubbleProperties(wip);
              return null;
          case FunctionComponent:
              bubbleProperties(wip);
              return null;
          default:
              {
                  console.warn('未处理的workTag类型', wip.tag);
              }
              break;
      }
  };
  function appendAllChildren(parent, wip) {
      let node = wip.child;
      while (node !== null) {
          if (node.tag === HostComponent || node.tag === HostText) {
              appendInitialChild(parent, node?.stateNode);
          }
          else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
          }
          if (node === wip) {
              return;
          }
          while (node.sibling === null) {
              if (node.return === null || node.return === wip) {
                  return;
              }
              node = node?.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
      }
  }
  function bubbleProperties(wip) {
      let subtreeFlags = NoFlags;
      let child = wip.child;
      while (child !== null) {
          subtreeFlags |= child.subtreeFlags;
          subtreeFlags |= child.flags;
          child.return = wip;
          child = child.sibling;
      }
      wip.subtreeFlags |= subtreeFlags;
  }

  const supportSymbol = typeof Symbol === 'function' && Symbol.for; //判断宿主环境是否支持Symbol
  const REACT_ELEMENT_TYPE = supportSymbol
      ? Symbol.for('react.element')
      : 0xeac7; //react元素类型
  const REACT_FRAGMENT_TYPE = supportSymbol
      ? Symbol.for('react.fragment')
      : 0xeacb; //react片段类型

  function ChildReconciler(shouldTrackEffects) {
      function deleteChild(returnFiber, childToDelete) {
          if (!shouldTrackEffects) {
              return;
          }
          const deletions = returnFiber.deletions;
          if (deletions === null) {
              returnFiber.deletions = [childToDelete];
              returnFiber.flags |= ChildDeletion;
          }
          else {
              deletions.push(childToDelete);
          }
      }
      function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackEffects) {
              return;
          }
          let childToDelete = currentFirstChild;
          while (childToDelete !== null) {
              deleteChild(returnFiber, childToDelete);
              childToDelete = childToDelete.sibling;
          }
      }
      function reconcileSingleElement(returnFiber, currentFiber, element) {
          const key = element.key;
          while (currentFiber !== null) {
              // update
              if (currentFiber.key === key) {
                  // key相同
                  if (element.$$typeof === REACT_ELEMENT_TYPE) {
                      if (currentFiber.type === element.type) {
                          let props = element.props;
                          if (element.type === REACT_FRAGMENT_TYPE) {
                              props = element.props.children;
                          }
                          // type相同
                          const existing = useFiber(currentFiber, props);
                          existing.return = returnFiber;
                          // 当前节点可复用，标记剩下的节点删除
                          deleteRemainingChildren(returnFiber, currentFiber.sibling);
                          return existing;
                      }
                      // key相同，type不同 删掉所有旧的
                      deleteRemainingChildren(returnFiber, currentFiber);
                      break;
                  }
                  else {
                      {
                          console.warn('还未实现的react类型', element);
                          break;
                      }
                  }
              }
              else {
                  // key不同，删掉旧的
                  deleteChild(returnFiber, currentFiber);
                  currentFiber = currentFiber.sibling;
              }
          }
          // 根据element创建fiber
          let fiber;
          if (element.type === REACT_FRAGMENT_TYPE) {
              fiber = createFiberFromFragment(element.props.children, key);
          }
          else {
              fiber = createFiberFromElement(element);
          }
          fiber.return = returnFiber;
          return fiber;
      }
      function reconcileSingleTextNode(returnFiber, currentFiber, content) {
          while (currentFiber !== null) {
              // update
              if (currentFiber.tag === HostText) {
                  // 类型没变，可以复用
                  const existing = useFiber(currentFiber, { content });
                  existing.return = returnFiber;
                  deleteRemainingChildren(returnFiber, currentFiber.sibling);
                  return existing;
              }
              deleteChild(returnFiber, currentFiber);
              currentFiber = currentFiber.sibling;
          }
          const fiber = new FiberNode(HostText, { content }, null);
          fiber.return = returnFiber;
          return fiber;
      }
      function placeSingleChild(fiber) {
          if (shouldTrackEffects && fiber.alternate === null) {
              fiber.flags |= Placement;
          }
          return fiber;
      }
      function reconcileChildrenArray(returnFiber, currentFirstChild, newChild) {
          // 最后一个可复用fiber在current中的index
          let lastPlacedIndex = 0;
          // 创建的最后一个fiber
          let lastNewFiber = null;
          // 创建的第一个fiber
          let firstNewFiber = null;
          // 1.将current保存在map中
          const existingChildren = new Map();
          let current = currentFirstChild;
          while (current !== null) {
              const keyToUse = current.key !== null ? current.key : current.index;
              existingChildren.set(keyToUse, current);
              current = current.sibling;
          }
          for (let i = 0; i < newChild.length; i++) {
              // 2.遍历newChild，寻找是否可复用
              const after = newChild[i];
              const newFiber = updateFromMap(returnFiber, existingChildren, i, after);
              if (newFiber === null) {
                  continue;
              }
              // 3. 标记移动还是插入
              newFiber.index = i;
              newFiber.return = returnFiber;
              if (lastNewFiber === null) {
                  lastNewFiber = newFiber;
                  firstNewFiber = newFiber;
              }
              else {
                  lastNewFiber.sibling = newFiber;
                  lastNewFiber = lastNewFiber.sibling;
              }
              if (!shouldTrackEffects) {
                  continue;
              }
              const current = newFiber.alternate;
              if (current !== null) {
                  const oldIndex = current.index;
                  if (oldIndex < lastPlacedIndex) {
                      // 移动
                      newFiber.flags |= Placement;
                      continue;
                  }
                  else {
                      // 不移动
                      lastPlacedIndex = oldIndex;
                  }
              }
              else {
                  // mount
                  newFiber.flags |= Placement;
              }
          }
          // 4. 将Map中剩下的标记为删除
          existingChildren.forEach((fiber) => {
              deleteChild(returnFiber, fiber);
          });
          return firstNewFiber;
      }
      function getElementKeyToUse(element, index) {
          if (Array.isArray(element) ||
              typeof element === 'string' ||
              typeof element === 'number' ||
              element === undefined ||
              element === null) {
              return index;
          }
          return element.key !== null ? element.key : index;
      }
      function updateFromMap(returnFiber, existingChildren, index, element) {
          const keyToUse = getElementKeyToUse(element, index);
          const before = existingChildren.get(keyToUse);
          // HostText
          if (typeof element === 'string' || typeof element === 'number') {
              if (before) {
                  if (before.tag === HostText) {
                      existingChildren.delete(keyToUse);
                      return useFiber(before, { content: element + '' });
                  }
              }
              return new FiberNode(HostText, { content: element + '' }, null);
          }
          // ReactElement
          if (typeof element === 'object' && element !== null) {
              switch (element.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                      if (element.type === REACT_FRAGMENT_TYPE) {
                          return updateFragment(returnFiber, before, element, keyToUse, existingChildren);
                      }
                      if (before) {
                          if (before.type === element.type) {
                              existingChildren.delete(keyToUse);
                              return useFiber(before, element.props);
                          }
                      }
                      return createFiberFromElement(element);
              }
          }
          if (Array.isArray(element)) {
              return updateFragment(returnFiber, before, element, keyToUse, existingChildren);
          }
          return null;
      }
      return function reconcileChildFibers(returnFiber, currentFiber, newChild) {
          // 判断Fragment
          const isUnkeyedTopLevelFragment = typeof newChild === 'object' &&
              newChild !== null &&
              newChild.type === REACT_FRAGMENT_TYPE &&
              newChild.key === null;
          if (isUnkeyedTopLevelFragment) {
              newChild = newChild.props.children;
          }
          // 判断当前fiber的类型
          if (typeof newChild === 'object' && newChild !== null) {
              // 多节点的情况 ul> li*3
              if (Array.isArray(newChild)) {
                  return reconcileChildrenArray(returnFiber, currentFiber, newChild);
              }
              switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                      return placeSingleChild(reconcileSingleElement(returnFiber, currentFiber, newChild));
                  default:
                      {
                          console.warn('未实现的reconcile类型', newChild);
                      }
                      break;
              }
          }
          // HostText
          if (typeof newChild === 'string' || typeof newChild === 'number') {
              return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFiber, newChild));
          }
          if (currentFiber !== null) {
              // 兜底删除
              deleteRemainingChildren(returnFiber, currentFiber);
          }
          {
              console.warn('未实现的reconcile类型', newChild);
          }
          return null;
      };
  }
  function useFiber(fiber, pendingProps) {
      const clone = createWorkInProgress(fiber, pendingProps);
      clone.index = 0;
      clone.sibling = null;
      return clone;
  }
  function updateFragment(returnFiber, current, elements, key, existingChildren) {
      let fiber;
      if (!current || current.tag !== Fragment) {
          fiber = createFiberFromFragment(elements, key);
      }
      else {
          existingChildren.delete(key);
          fiber = useFiber(current, elements);
      }
      fiber.return = returnFiber;
      return fiber;
  }
  const reconcileChildFibers = ChildReconciler(true);
  const mountChildFibers = ChildReconciler(false);

  const internals = React__namespace.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

  let currentlyRenderingFiber = null;
  let workInProgressHook = null;
  let currentHook = null;
  const { currentDispatcher } = internals; // 获取当前调度器
  function renderWithHooks(wip) {
      currentlyRenderingFiber = wip; // 设置当前正在渲染的fiber节点
      const current = wip.alternate; // 获取备用节点
      if (current !== null) {
          //update
          currentDispatcher.current = HooksDispatcherUpdate;
          // 在更新时，保持之前的hook状态
          wip.memoizedState = current.memoizedState;
      }
      else {
          //mmount
          currentDispatcher.current = HooksDispatcherOnMount;
          wip.memoizedState = null; // 初始化memoizedState为null
      }
      const Component = wip.type; // 获取组件类型
      const props = wip.pengingProps; // 获取待处理的属性
      const children = Component(props); // 调用组件函数获取子节点
      //重置操作
      currentlyRenderingFiber = null; // 清除当前渲染的fiber节点
      workInProgressHook = null;
      currentHook = null;
      return children;
  }
  const HooksDispatcherOnMount = {
      useState: mountState
  };
  const HooksDispatcherUpdate = {
      useState: updateState
  };
  function mountState(initialState) {
      const hook = mountWorkInProgressHook(); // 创建一个新的hook
      let memoizedState; // 定义hook的状态
      if (initialState instanceof Function) {
          // 如果初始状态是一个函数，则调用它
          memoizedState = initialState();
      }
      else {
          // 否则直接使用初始状态
          memoizedState = initialState;
      }
      const queue = createUpdateQueue(); // 创建一个更新队列
      hook.updateQueue = queue; // 将更新队列赋值给hook
      // @ts-ignore
      const dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
      queue.dispatch = dispatch;
      return [memoizedState, dispatch];
  }
  function updateState(initialState) {
      const hook = updateWorkInProgressHook(); // 创建一个新的hook
      //计算新state的逻辑
      const queue = hook.updateQueue;
      const pending = queue.shared.pending;
      if (pending !== null) {
          const { memoizedState } = processUpdateQueue(hook.memoizedState, pending);
          hook.memoizedState = memoizedState;
      }
      return [hook.memoizedState, queue.dispatch];
  }
  function updateWorkInProgressHook() {
      let nextCurrentHook = null;
      if (currentHook === null) {
          const current = currentlyRenderingFiber?.alternate;
          if (current !== null) {
              nextCurrentHook = current?.memoizedState;
          }
          else {
              nextCurrentHook = null;
          }
      }
      else {
          nextCurrentHook = currentHook.next;
      }
      if (nextCurrentHook === null) {
          throw new Error(`当前组件: ${currentlyRenderingFiber?.type} 在更新时hook比上一次多`);
      }
      currentHook = nextCurrentHook;
      const newHook = {
          memoizedState: currentHook.memoizedState,
          updateQueue: currentHook.updateQueue,
          next: null
      };
      if (workInProgressHook === null) {
          if (currentlyRenderingFiber === null) {
              throw new Error('hook只能在函数组件中执行');
          }
          else {
              workInProgressHook = newHook;
              currentlyRenderingFiber.memoizedState = workInProgressHook;
          }
      }
      else {
          workInProgressHook.next = newHook;
          workInProgressHook = newHook;
      }
      return workInProgressHook;
  }
  function dispatchSetState(fiber, updateQueue, action) {
      const update = createUpdate(action);
      enqueueUpdate(updateQueue, update);
      scheduleUpdateOnFiber(fiber);
  }
  function mountWorkInProgressHook() {
      const hook = {
          memoizedState: null, // 初始化hook的状态为null
          updateQueue: null, // 初始化更新队列为null
          next: null // 链表结构的下一个hook
      };
      if (workInProgressHook === null) {
          // 第一个hook 并且是mount时候
          if (currentlyRenderingFiber === null) {
              throw new Error('hook只能在函数组件中执行');
          }
          else {
              workInProgressHook = hook;
              currentlyRenderingFiber.memoizedState = workInProgressHook;
          }
      }
      else {
          // 非第一个hook mount后续的hook
          workInProgressHook.next = hook; // 将新hook添加到链表中
          workInProgressHook = hook; // 更新当前工作中的hook
      }
      return workInProgressHook; // 返回当前工作中的hook
  }

  //递归中的递阶段
  const beginWork = (wip) => {
      //比较，返回子fiberNode
      switch (wip.tag) {
          case HostRoot:
              return updateHostRoot(wip); // 更新根节点
          case HostComponent:
              return updateHostComponent(wip); // 更新组件节点
          case HostText:
              return null;
          case FunctionComponent:
              return updateFunctionComponent(wip);
          default:
              {
                  console.warn('beginWork未实现的类型');
              }
              break;
      }
      return null;
  };
  function updateFunctionComponent(wip) {
      const nextChildren = renderWithHooks(wip); // 使用钩子渲染组件
      reconileChildren(wip, nextChildren); // 递归处理子节点
      return wip.child; // 返回子节点
  }
  function updateHostRoot(wip) {
      const baseState = wip.memoizedState; // 获取基础状态
      const updateQueue = wip.updateQueue; // 获取更新队列
      const pending = updateQueue.shared.pending; // 获取待处理的更新
      updateQueue.shared.pending = null; // 清空待处理的更新
      const { memoizedState } = processUpdateQueue(baseState, pending); // 处理更新队列
      wip.memoizedState = memoizedState; // 更新已处理状态
      const nextChildren = wip.memoizedState; // 获取待处理的子节点
      reconileChildren(wip, nextChildren); // 递归处理子节点
      return wip.child; // 返回子节点
  }
  function updateHostComponent(wip) {
      const nextProps = wip.pengingProps; // 获取待处理的属性
      const nextChildren = nextProps.children; // 获取待处理的属性
      reconileChildren(wip, nextChildren); // 递归处理子节点
      return wip.child; // 返回子节点
  }
  function reconileChildren(wip, children) {
      const current = wip.alternate; // 获取备用节点
      if (current !== null) {
          //update
          wip.child = reconcileChildFibers(wip, current?.child, children); // 更新子节点
      }
      else {
          wip.child = mountChildFibers(wip, null, children); // 创建新的子节点
      }
  }

  let nextEffect = null; // 下一个副作用节点
  const commitMutationEffects = (finishedWork) => {
      nextEffect = finishedWork;
      const commitMutationEffectsOnFiber = (finishedWork) => {
          const flags = finishedWork.flags; // 获取当前Fiber节点的标记
          if ((flags & Placement) !== NoFlags) {
              commitPlacement(finishedWork);
              finishedWork.flags &= ~Placement;
          }
          if ((flags & Update) !== NoFlags) {
              commitUpdate(finishedWork);
              finishedWork.flags &= ~Update;
          }
          if ((flags & ChildDeletion) !== NoFlags) {
              const deletions = finishedWork.deletions;
              if (deletions !== null) {
                  deletions.forEach(ChildDeletion => {
                      commitDeletion(ChildDeletion);
                  });
              }
              finishedWork.flags &= ~ChildDeletion;
          }
      };
      function commitDeletion(childToDelete) {
          let rootHostNode = null;
          //递归子树
          commitNestedComponent(childToDelete, unmountFiber => {
              switch (unmountFiber.tag) {
                  case HostComponent:
                      if (rootHostNode === null) {
                          rootHostNode = unmountFiber;
                      }
                      return;
                  case HostRoot:
                      if (rootHostNode === null) {
                          rootHostNode = unmountFiber;
                      }
                      return;
                  case HostText:
                      if (rootHostNode === null) {
                          rootHostNode = unmountFiber;
                      }
                      return;
                  case FunctionComponent:
                      return;
                  default:
                      {
                          console.warn("未实现的commitDeletion类型", unmountFiber.tag);
                      }
                      break;
              }
          });
          //移除rootHostNode的DOM
          if (rootHostNode !== null) {
              const hostParent = getHostParent(rootHostNode);
              if (hostParent !== null && rootHostNode.stateNode) {
                  removeChild(rootHostNode.stateNode, hostParent);
              }
          }
          childToDelete.return = null;
          childToDelete.child = null;
      }
      function commitNestedComponent(root, onCommitUnmount) {
          let node = root;
          while (true) {
              onCommitUnmount(node);
              if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
              }
              if (node === root) {
                  return;
              }
              while (node.sibling === null) {
                  if (node.return === null || node.return === root) {
                      return;
                  }
                  node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
          }
      }
      function commitPlacement(finishedWork) {
          {
              console.warn('commitPlacement', finishedWork);
          }
          const hostParent = getHostParent(finishedWork); // 获取宿主父节点
          // 只有当hostParent不为null时才执行插入操作
          if (hostParent !== null) {
              appendPlacementNodeIntoContainer(finishedWork, hostParent); // 将节点插入到
          }
      }
      function getHostParent(fiber) {
          let parent = fiber.return; // 获取父节点
          while (parent) {
              const parentTag = parent.tag; // 获取父节点的类型
              if (parentTag === HostComponent) {
                  return parent.stateNode; // 如果父节点是HostComponent，返回其状态节点
              }
              if (parentTag === HostRoot) {
                  return parent.stateNode.container;
              }
              parent = parent.return; // 向上回溯到父节点
          }
          {
              console.warn('未找到HostParent');
          }
          return null; // 返回null而不是null as any
      }
      function appendPlacementNodeIntoContainer(finishedWork, hostParent) {
          if (finishedWork.tag === HostComponent || finishedWork.tag === HostRoot) {
              appendChildToContainer(hostParent, finishedWork.stateNode);
              return;
          }
          const child = finishedWork.child; // 获取子节点
          if (child !== null) {
              appendPlacementNodeIntoContainer(child, hostParent); // 递归处理子节点
              let sibling = child.sibling; // 获取兄弟节点
              while (sibling !== null) {
                  appendPlacementNodeIntoContainer(sibling, hostParent); // 递归处理兄弟节点
                  sibling = sibling.sibling; // 获取下一个兄弟节点
              }
          }
      }
      while (nextEffect !== null) {
          const child = nextEffect.child;
          if ((nextEffect.subtreeFlags & MutationMask) !== NoFlags && child !== null) {
              nextEffect = child; // 如果有子节点，继续处理子节点
          }
          else {
              //向上遍历
              up: while (nextEffect !== null) {
                  commitMutationEffectsOnFiber(nextEffect); // 提交当前副作用节点的变更
                  const sibling = nextEffect.sibling; // 获取兄弟节点
                  if (sibling !== null) {
                      nextEffect = sibling; // 如果有兄弟节点，继续处理兄弟节点
                      break up; // 跳出循环，继续处理下一个副作用节点
                  }
                  nextEffect = nextEffect.return; // 如果没有兄弟节点，向上回溯到父节点
              }
          }
      }
  };

  let workInProgress = null;
  function prepareRefreshStack(root) {
      if (root.current === null) {
          {
              console.warn('root.current 为 null');
          }
          return;
      }
      workInProgress = createWorkInProgress(root.current, {}); // 设置当前工作中的Fiber节点
  }
  function scheduleUpdateOnFiber(fiber) {
      //调度功能
      const root = markUpdateFromFiberToRoot(fiber); // 标记从Fiber节点到根节点的更新
      if (root === null) {
          {
              console.warn('无法找到FiberRootNode');
          }
          return;
      }
      renderRoot(root); // 渲染根节点
  }
  function markUpdateFromFiberToRoot(fiber) {
      let node = fiber;
      let parent = fiber.return; // 获取父节点
      while (parent !== null) {
          node = parent; // 向上回溯到根节点
          parent = parent.return; // 获取父节点
      }
      if (node.tag === HostRoot) { // 如果根节点是HostRoot类型
          return node.stateNode; // 返回根节点的状态节点
      }
      return null; // 如果没有找到根节点，返回null
  }
  function renderRoot(root) {
      prepareRefreshStack(root);
      if (workInProgress === null) {
          {
              console.warn('workInProgress 为 null，跳过渲染');
          }
          return;
      }
      do {
          try {
              workLoop();
              break; // 如果工作循环完成，跳出循环
          }
          catch (error) {
              // 处理错误逻辑，例如记录错误或重置工作状态
              {
                  console.error('workLoop发生错误:', error);
              }
              workInProgress = null; // 重置当前工作中的Fiber节点
          }
      } while (true);
      const finishedWork = root.current.alternate;
      root.finishedWork = finishedWork; // 设置完成的工作节点
      commitRoot(root); // 提交根节点
  }
  function commitRoot(root) {
      const finishedWork = root.finishedWork; // 获取完成的工作节点
      if (finishedWork === null) {
          return; // 如果没有完成的工作节点，直接返回
      }
      {
          console.warn('commit阶段开始', finishedWork);
      }
      //重置
      root.finishedWork = null;
      //判断是否存在3个子阶段需要执行的操作
      const subtreeFlags = (finishedWork.subtreeFlags & (MutationMask)) !== NoFlags; // 检查子树标记是否包含变更标记
      const rootHasEffect = (finishedWork.flags & (MutationMask)) !== NoFlags; // 检查根节点是否有副作用标记
      if (subtreeFlags || rootHasEffect) {
          //beforeMutation
          //mutation Placement
          commitMutationEffects(finishedWork);
          root.current = finishedWork; // 更新当前节点为完成的工作节点
          //layout
      }
      else {
          root.current = finishedWork;
      }
  }
  function workLoop() {
      while (workInProgress !== null) {
          // 执行工作单元
          performUnitOfWork(workInProgress);
      }
  }
  function performUnitOfWork(fiber) {
      const next = beginWork(fiber);
      fiber.memoizedProps = fiber.pengingProps; // 将待处理的属性设置为已处理的属性
      if (next === null) {
          completeUnitOfWork(fiber); // 如果没有下一个工作单元，完成当前工作单元
      }
      else {
          workInProgress = next; // 设置下一个工作单元为当前工作中的Fiber节点
      }
  }
  function completeUnitOfWork(fiber) {
      let node = fiber;
      do {
          completeWork(node); // 完成当前工作单元
          const sibling = node.sibling; // 获取兄弟节点
          if (sibling !== null) {
              workInProgress = sibling; // 如果有兄弟节点，设置为当前工作中的Fiber节点
              return; // 结束当前工作单元的处理
          }
          node = node.return; // 向上回溯到父节点
          workInProgress = node; // 更新当前工作中的Fiber节点
      } while (node !== null);
  }

  function createContainer(container) {
      const hostRootFiber = new FiberNode(HostRoot, {}, null); // 创建根Fiber节点
      const root = new FiberRootNode(container, hostRootFiber); // 创建Fiber根节点
      hostRootFiber.updateQueue = createUpdateQueue(); // 初始化更新队列
      hostRootFiber.memoizedState = null; // 初始化memoizedState为null
      return root;
  }
  function updateContainer(element, root) {
      const hostRootFiber = root.current; // 获取当前的根Fiber节点
      const update = createUpdate(element); // 创建更新
      enqueueUpdate((hostRootFiber.updateQueue), update); // 将更新添加到更新队列
      scheduleUpdateOnFiber(hostRootFiber); // 调度更新
      return element; // 返回更新的元素
  }

  function createRoot(container) {
      const root = createContainer(container); // 创建根容器
      return {
          render(element) {
              initEvent(container, 'click');
              updateContainer(element, root); // 更新容器中的内容
          }
      };
  }

  var ReactDOM = /*#__PURE__*/Object.freeze({
    __proto__: null,
    createRoot: createRoot
  });

  return ReactDOM;

}));
