(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('scheduler')) :
  typeof define === 'function' && define.amd ? define(['scheduler'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.ReactNoopRenderer = factory(global.Scheduler));
})(this, (function (Scheduler) { 'use strict';

  function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    }
    n.default = e;
    return Object.freeze(n);
  }

  var Scheduler__namespace = /*#__PURE__*/_interopNamespaceDefault(Scheduler);

  const FunctionComponent = 0;
  const HostRoot = 3;
  const HostComponent = 5;
  const HostText = 6;
  const Fragment = 7;

  const NoFlags = 0b00000000; // 没有标记
  const Placement = 0b00000001; // 插入标记
  const Update = 0b00000010; // 更新标记
  const ChildDeletion = 0b00000100; // 子节点删除标记
  const PassiveEffect = 0b0001000;
  const HookHasEffect = 0b0010000;
  const MutationMask = Placement | Update | ChildDeletion;
  const PassiveMask = PassiveEffect | ChildDeletion;

  const SyncLane = 0b0001;
  const NoLane = 0b0000;
  const NoLanes = 0b0000;
  const InputContinuousLane = 0b0010;
  const DefaultLane = 0b0100;
  function mergeLanes(laneA, laneB) {
      return laneA | laneB;
  }
  function requestUpdateLane() {
      const currentSchedulerPriority = Scheduler.unstable_getCurrentPriorityLevel();
      const lane = schedulerPriorityToLane(currentSchedulerPriority);
      return lane;
  }
  function getHighestPriorityLane(lanes) {
      return lanes & -lanes;
  }
  function isSubsetOfLanes(set, subset) {
      return (set & subset) === subset;
  }
  function markRootFinished(root, lane) {
      root.pendingLanes &= ~lane;
      root.suspendedLanes = NoLanes;
      root.pingedLanes = NoLanes;
  }
  function lanesToSchedulerPriority(lanes) {
      const lane = getHighestPriorityLane(lanes);
      if (lane === SyncLane) {
          return Scheduler.unstable_ImmediatePriority;
      }
      if (lane === InputContinuousLane) {
          return Scheduler.unstable_UserBlockingPriority;
      }
      if (lane === DefaultLane) {
          return Scheduler.unstable_NormalPriority;
      }
      return Scheduler.unstable_IdlePriority;
  }
  function schedulerPriorityToLane(schedulerPriority) {
      if (schedulerPriority === Scheduler.unstable_ImmediatePriority) {
          return SyncLane;
      }
      if (schedulerPriority === Scheduler.unstable_UserBlockingPriority) {
          return InputContinuousLane;
      }
      if (schedulerPriority === Scheduler.unstable_NormalPriority) {
          return DefaultLane;
      }
      return NoLane;
  }

  class FiberNode {
      tag; // Fiber的类型
      key; // 唯一标识符
      type; // 元素类型
      ref; // 引用
      stateNode; // 关联的DOM节点或组件实例
      pendingProps; // 待处理的属性
      return; // 指向父Fiber节点
      sibling; // 指向兄弟Fiber节点
      child; // 指向子Fiber节点
      index; // 在兄弟节点中的索引
      memoizedProps; // 已处理的属性
      memoizedState; // 已处理的状态
      alternate; // 用于在workinProgess与current两棵缓存树中进行切换
      flags; // 用于标记Fiber的状态，如更新、删除等
      subtreeFlags; // 子树的标记，用于标记子节点的状态
      updateQueue; // 更新队列，用于存储待处理的更新
      deletions;
      constructor(tag, pendingProps, key) {
          this.tag = tag; // Fiber的类型
          this.key = key || null; // 唯一标识符  
          this.type = null; // 元素类型   
          //树状结构
          this.return = null; // 指向父Fiber节点
          this.sibling = null; // 指向兄弟Fiber节点
          this.child = null; // 指向子Fiber节点
          this.index = 0; // 在兄弟节点中的索引
          this.ref = null; // 引用
          //作为工作单元
          this.pendingProps = pendingProps; // 待处理的属性
          this.memoizedProps = null; // 已处理的属性
          this.memoizedState = null; // 已处理的状态
          this.updateQueue = null; // 更新队列，用于存储待处理的更新
          this.alternate = null; // 用于在workinProgess与current两棵缓存树中进行切换
          //副作用
          this.flags = NoFlags; //用于标记Fiber的状态，如更新、删除等
          this.subtreeFlags = NoFlags; // 子树的标记，用于标记子节点的状态
          this.deletions = null;
      }
  }
  class FiberRootNode {
      container; // 容器信息
      current; // 当前的Fiber节点
      pendingLanes; // 待处理的更新队列
      finishedLane; // 已完成的更新队列
      finishedLanes; // 已完成的更新队列
      finishedWork; // 完成的Fiber节点
      suspendedLanes; // 挂起的lanes
      pingedLanes; // 被ping的lanes
      pendingPassiveEffects; // 待处理的副作用
      callbackNode; // 回调节点
      callbackPriority; // 回调节点优先级
      constructor(container, hostRootFiber) {
          this.container = container; // 容器信息
          this.current = hostRootFiber; // 当前的Fiber节点
          hostRootFiber.stateNode = this;
          this.finishedWork = null; // 完成的Fiber节点，初始为null
          this.pendingLanes = NoLanes; // 待处理的更新队列
          this.finishedLane = NoLane; // 已完成的更新队列
          this.finishedLanes = NoLanes; // 已完成的更新队列
          this.suspendedLanes = NoLanes; // 挂起的lanes
          this.pingedLanes = NoLanes; // 被ping的lanes
          this.pendingPassiveEffects = {
              unmount: [],
              update: []
          };
          this.callbackNode = null; // 回调节点
          this.callbackPriority = NoLane; // 回调节点优先级
      }
  }
  const createWorkInProgress = (current, pendingProps) => {
      let wip = current.alternate; // 获取当前Fiber节点的备用节点
      if (wip === null) {
          //mount
          wip = new FiberNode(current.tag, pendingProps, current.key); // 如果备用节点不存在，创建一个新的Fiber节点
          wip.type = current.type; // 设置备用节点的类型
          wip.stateNode = current.stateNode; // 关联状态节点
          wip.alternate = current; // 设置备用节点的alternate指向当前节点
          current.alternate = wip; // 设置当前节点的alternate指向备用节点
      }
      else {
          //update
          wip.pendingProps = pendingProps; // 更新备用节点的待处理属性
          wip.flags = NoFlags; // 重置备用节点的标记
          wip.subtreeFlags = NoFlags;
          wip.deletions = null;
      }
      wip.type = current.type; // 确保备用节点的类型与当前节点一致
      wip.updateQueue = current.updateQueue; // 继承当前节点的更新队列
      wip.child = current.child; // 继承当前节点的子节点
      wip.memoizedProps = current.memoizedProps; // 继承当前节点的已处理属性
      wip.memoizedState = current.memoizedState; // 继承当前
      return wip; // 返回备用节点
  };
  const createFiberFromElement = (element) => {
      const { type, key, props } = element; // 解构React元素的类型、键和属性
      let fiberTag = FunctionComponent;
      if (typeof type === 'string') {
          fiberTag = HostComponent; // 如果类型是字符串，设置为HostComponent 
      }
      else if (typeof type === 'function' && true) {
          console.warn('createFiberFromElement未实现的类型');
      }
      const fiber = new FiberNode(fiberTag, props, key); // 创建新的Fiber节点
      fiber.type = type; // 设置Fiber节点的类型
      return fiber; // 返回创建的Fiber节点
  };
  const createFiberFromFragment = (elements, key) => {
      const fiber = new FiberNode(Fragment, elements, key);
      // fiber.type = Fragment;
      return fiber;
  };

  const createUpdate = (action, lane) => {
      return {
          action,
          lane,
          next: null,
      };
  };
  const createUpdateQueue = () => {
      return {
          shared: {
              pending: null, // 初始化时没有待处理的更新
          },
          dispatch: null
      };
  };
  const enqueueUpdate = (updateQueue, update) => {
      const pending = updateQueue.shared.pending;
      if (pending === null) {
          update.next = update;
      }
      else {
          update.next = pending.next;
          pending.next = update;
      }
      updateQueue.shared.pending = update;
  };
  const processUpdateQueue = (baseState, pendingUpdate, renderLane) => {
      const result = {
          memoizedState: baseState,
          baseState,
          baseQueue: null,
      }; // 初始化结果为基础状态
      if (pendingUpdate !== null) {
          let first = pendingUpdate.next;
          let pending = pendingUpdate.next;
          let newBaseState = baseState;
          let newBaseQueueFirst = null;
          let newBaseQueueLast = null;
          let newState = baseState;
          do {
              const updateLane = pending.lane;
              if (!isSubsetOfLanes(renderLane, updateLane)) {
                  //优先级不够 被跳过
                  const clone = createUpdate(pending.action, pending.lane);
                  if (newBaseQueueLast === null) {
                      newBaseQueueFirst = clone;
                      newBaseQueueLast = clone;
                      newBaseState = newState;
                  }
                  else {
                      newBaseQueueLast.next = clone;
                      newBaseQueueLast = clone;
                  }
              }
              else {
                  //优先级足够
                  if (newBaseQueueLast !== null) {
                      const clone = createUpdate(pending.action, NoLane);
                      newBaseQueueLast.next = clone;
                      newBaseQueueLast = clone;
                  }
                  const action = pending.action;
                  if (action instanceof Function) {
                      newState = action(newState); // 如果action是函数，执行它并更新newState
                  }
                  else {
                      newState = action; // 否则直接使用action作为新的状态
                  }
              }
              pending = pending.next;
          } while (pending !== first && pending !== null);
          if (newBaseQueueLast === null) {
              //本次计算没有update被跳过
              newBaseState = newState;
          }
          else {
              newBaseQueueLast.next = newBaseQueueFirst;
          }
          result.memoizedState = newState; // 使用newState作为最终状态
          result.baseState = newBaseState;
          result.baseQueue = newBaseQueueLast;
      }
      return result;
  };

  let instanceCounter = 0;
  const createInstance = (type, props) => {
      const instance = {
          id: instanceCounter++,
          type,
          children: [],
          parent: -1,
          props,
      };
      return instance;
  };
  const appendInitialChild = (parent, child) => {
      const prevParentID = child.parent;
      const parentID = 'rootId' in parent ? parent.rootId : parent.id;
      if (prevParentID !== -1 && prevParentID !== parentID) {
          throw new Error('不能重复挂载');
      }
      child.parent = parentID;
      parent.children.push(child);
  };
  const createTextInstance = (content) => {
      const instance = {
          text: content,
          id: instanceCounter++,
          parent: -1
      };
      return instance;
  };
  const appendChildToContainer = (parent, child) => {
      const prevParentID = child.parent;
      if (prevParentID !== -1 && prevParentID !== parent.rootId) {
          throw new Error('不能重复挂载');
      }
      child.parent = parent.rootId;
      parent.children.push(child);
  };
  const commitUpdate = (fiber) => {
      switch (fiber.tag) {
          case HostText:
              const text = fiber.memoizedProps?.content;
              return commitTextUpdate(fiber.stateNode, text);
          case HostComponent:
              return updateFiberProps(fiber.stateNode, fiber.memoizedProps);
          default:
              {
                  console.warn("未实现的update类型");
              }
              return;
      }
  };
  function commitTextUpdate(textInstance, content) {
      textInstance.text = content;
  }
  function updateFiberProps(node, props) {
      // No-op for noop renderer
  }
  const removeChild = (child, container) => {
      const index = container.children.indexOf(child);
      if (index === -1) {
          throw new Error('child 不存在');
      }
      container.children.splice(index, 1);
  };
  function insertChildToContainer(child, container, before) {
      const beforeIndex = container.children.indexOf(before);
      if (beforeIndex === -1) {
          throw new Error('before 不存在');
      }
      const index = container.children.indexOf(child);
      if (index !== -1) {
          container.children.splice(index, 1);
      }
      container.children.splice(beforeIndex, 0, child);
  }
  const scheduleMicroTask = typeof queueMicrotask === 'function' ?
      queueMicrotask
      : typeof Promise === 'function'
          ? (callback) => Promise.resolve(null).then(callback)
          : setTimeout;

  function markUpdate(wip) {
      wip.flags |= Update;
  }
  const completeWork = (wip) => {
      //递归中的归
      const newProps = wip.pendingProps; // 获取待处理的属性
      const current = wip.alternate; // 获取当前的备用节点
      switch (wip.tag) {
          case HostComponent:
              if (current !== null && wip.stateNode) {
                  //update
                  //判断props是否变化
                  //如果变化则添加update tag
                  markUpdate(wip);
              }
              else {
                  //1.构建DOM
                  const instance = createInstance(wip.type, newProps);
                  //2.将DOM插入到DOM树中
                  appendAllChildren(instance, wip); // 将子节点添加到实例中
                  wip.stateNode = instance; // 将实例赋值给wip的stateNode
              }
              bubbleProperties(wip); // 处理子节点的属性
              return null;
          case HostText:
              if (current !== null && wip.stateNode) {
                  //update
                  const oldText = current.memoizedProps.content;
                  const newText = newProps.content;
                  if (oldText !== newText) {
                      markUpdate(wip);
                  }
              }
              else {
                  //构建DOM
                  const instance = createTextInstance(newProps.content);
                  wip.stateNode = instance; // 将实例赋值给wip的stateNode
              }
              bubbleProperties(wip); // 处理子节点的属性
              return null;
          case HostRoot:
          case FunctionComponent:
          case Fragment:
              bubbleProperties(wip);
              return null;
          default:
              {
                  console.warn('未处理的workTag类型', wip.tag);
              }
              break;
      }
  };
  function appendAllChildren(parent, wip) {
      let node = wip.child;
      while (node !== null) {
          if (node.tag === HostComponent || node.tag === HostText) {
              appendInitialChild(parent, node?.stateNode);
          }
          else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
          }
          if (node === wip) {
              return;
          }
          while (node.sibling === null) {
              if (node.return === null || node.return === wip) {
                  return;
              }
              node = node?.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
      }
  }
  function bubbleProperties(wip) {
      let subtreeFlags = NoFlags;
      let child = wip.child;
      while (child !== null) {
          subtreeFlags |= child.subtreeFlags;
          subtreeFlags |= child.flags;
          child.return = wip;
          child = child.sibling;
      }
      wip.subtreeFlags |= subtreeFlags;
  }

  const supportSymbol = typeof Symbol === 'function' && Symbol.for; //判断宿主环境是否支持Symbol
  const REACT_ELEMENT_TYPE = supportSymbol
      ? Symbol.for('react.element')
      : 0xeac7; //react元素类型
  const REACT_FRAGMENT_TYPE = supportSymbol
      ? Symbol.for('react.fragment')
      : 0xeacb; //react片段类型

  function ChildReconciler(shouldTrackEffects) {
      function deleteChild(returnFiber, childToDelete) {
          if (!shouldTrackEffects) {
              return;
          }
          const deletions = returnFiber.deletions;
          if (deletions === null) {
              returnFiber.deletions = [childToDelete];
              returnFiber.flags |= ChildDeletion;
          }
          else {
              deletions.push(childToDelete);
          }
      }
      function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackEffects) {
              return;
          }
          let childToDelete = currentFirstChild;
          while (childToDelete !== null) {
              deleteChild(returnFiber, childToDelete);
              childToDelete = childToDelete.sibling;
          }
      }
      function reconcileSingleElement(returnFiber, currentFiber, element) {
          const key = element.key;
          while (currentFiber !== null) {
              // update
              if (currentFiber.key === key) {
                  // key相同
                  if (element.$$typeof === REACT_ELEMENT_TYPE) {
                      if (currentFiber.type === element.type) {
                          let props = element.props;
                          if (element.type === REACT_FRAGMENT_TYPE) {
                              props = element.props.children;
                          }
                          // type相同
                          const existing = useFiber(currentFiber, props);
                          existing.return = returnFiber;
                          // 当前节点可复用，标记剩下的节点删除
                          deleteRemainingChildren(returnFiber, currentFiber.sibling);
                          return existing;
                      }
                      // key相同，type不同 删掉所有旧的
                      deleteRemainingChildren(returnFiber, currentFiber);
                      break;
                  }
                  else {
                      {
                          console.warn('还未实现的react类型', element);
                          break;
                      }
                  }
              }
              else {
                  // key不同，删掉旧的
                  deleteChild(returnFiber, currentFiber);
                  currentFiber = currentFiber.sibling;
              }
          }
          // 根据element创建fiber
          let fiber;
          if (element.type === REACT_FRAGMENT_TYPE) {
              fiber = createFiberFromFragment(element.props.children, key);
          }
          else {
              fiber = createFiberFromElement(element);
          }
          fiber.return = returnFiber;
          return fiber;
      }
      function reconcileSingleTextNode(returnFiber, currentFiber, content) {
          while (currentFiber !== null) {
              // update
              if (currentFiber.tag === HostText) {
                  // 类型没变，可以复用
                  const existing = useFiber(currentFiber, { content });
                  existing.return = returnFiber;
                  deleteRemainingChildren(returnFiber, currentFiber.sibling);
                  return existing;
              }
              deleteChild(returnFiber, currentFiber);
              currentFiber = currentFiber.sibling;
          }
          const fiber = new FiberNode(HostText, { content }, null);
          fiber.return = returnFiber;
          return fiber;
      }
      function placeSingleChild(fiber) {
          // 在首次挂载时，总是需要设置 Placement 标志
          // 即使 shouldTrackEffects 为 false，也要确保 DOM 元素被插入
          if (fiber.alternate === null) {
              fiber.flags |= Placement;
          }
          return fiber;
      }
      function reconcileChildrenArray(returnFiber, currentFirstChild, newChild) {
          // 最后一个可复用fiber在current中的index
          let lastPlacedIndex = 0;
          // 创建的最后一个fiber
          let lastNewFiber = null;
          // 创建的第一个fiber
          let firstNewFiber = null;
          // 1.将current保存在map中
          const existingChildren = new Map();
          let current = currentFirstChild;
          while (current !== null) {
              const keyToUse = current.key !== null ? current.key : current.index;
              existingChildren.set(keyToUse, current);
              current = current.sibling;
          }
          for (let i = 0; i < newChild.length; i++) {
              // 2.遍历newChild，寻找是否可复用
              const after = newChild[i];
              const newFiber = updateFromMap(returnFiber, existingChildren, i, after);
              if (newFiber === null) {
                  continue;
              }
              // 3. 标记移动还是插入
              newFiber.index = i;
              newFiber.return = returnFiber;
              if (lastNewFiber === null) {
                  lastNewFiber = newFiber;
                  firstNewFiber = newFiber;
              }
              else {
                  lastNewFiber.sibling = newFiber;
                  lastNewFiber = lastNewFiber.sibling;
              }
              if (!shouldTrackEffects) {
                  continue;
              }
              const current = newFiber.alternate;
              if (current !== null) {
                  const oldIndex = current.index;
                  if (oldIndex < lastPlacedIndex) {
                      // 移动
                      newFiber.flags |= Placement;
                      continue;
                  }
                  else {
                      // 不移动
                      lastPlacedIndex = oldIndex;
                  }
              }
              else {
                  // mount
                  newFiber.flags |= Placement;
              }
          }
          // 4. 将Map中剩下的标记为删除
          existingChildren.forEach((fiber) => {
              deleteChild(returnFiber, fiber);
          });
          return firstNewFiber;
      }
      function getElementKeyToUse(element, index) {
          if (Array.isArray(element) ||
              typeof element === 'string' ||
              typeof element === 'number' ||
              element === undefined ||
              element === null) {
              return index;
          }
          return element.key !== null ? element.key : index;
      }
      function updateFromMap(returnFiber, existingChildren, index, element) {
          const keyToUse = getElementKeyToUse(element, index);
          const before = existingChildren.get(keyToUse);
          // 判断当前fiber的类型是ReactElement还是HostText
          if (typeof element === 'object' && element !== null) {
              switch (element.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                      if (element.type === REACT_FRAGMENT_TYPE) {
                          return updateFragment$1(returnFiber, before, element, keyToUse, existingChildren);
                      }
                      if (before) {
                          if (before.type === element.type) {
                              existingChildren.delete(keyToUse);
                              return useFiber(before, element.props);
                          }
                      }
                      return createFiberFromElement(element);
              }
          }
          // HostText
          if (typeof element === 'string' || typeof element === 'number') {
              if (before) {
                  if (before.tag === HostText) {
                      existingChildren.delete(keyToUse);
                      return useFiber(before, { content: element + '' });
                  }
              }
              return new FiberNode(HostText, { content: element + '' }, null);
          }
          if (Array.isArray(element)) {
              return updateFragment$1(returnFiber, before, element, keyToUse, existingChildren);
          }
          return null;
      }
      return function reconcileChildFibers(returnFiber, currentFiber, newChild) {
          // 判断Fragment
          const isUnkeyedTopLevelFragment = typeof newChild === 'object' &&
              newChild !== null &&
              newChild.type === REACT_FRAGMENT_TYPE &&
              newChild.key === null;
          if (isUnkeyedTopLevelFragment) {
              newChild = newChild.props.children;
          }
          // 判断当前fiber的类型
          if (typeof newChild === 'object' && newChild !== null) {
              // 多节点的情况 ul> li*3
              if (Array.isArray(newChild)) {
                  return reconcileChildrenArray(returnFiber, currentFiber, newChild);
              }
              switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                      return placeSingleChild(reconcileSingleElement(returnFiber, currentFiber, newChild));
                  default:
                      {
                          console.warn('未实现的reconcile类型', newChild);
                      }
                      break;
              }
          }
          // HostText
          if (typeof newChild === 'string' || typeof newChild === 'number') {
              return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFiber, newChild));
          }
          if (currentFiber !== null) {
              // 兜底删除
              deleteRemainingChildren(returnFiber, currentFiber);
          }
          {
              console.warn('未实现的reconcile类型', newChild);
          }
          return null;
      };
  }
  function useFiber(fiber, pendingProps) {
      const clone = createWorkInProgress(fiber, pendingProps);
      clone.index = 0;
      clone.sibling = null;
      return clone;
  }
  function updateFragment$1(returnFiber, current, elements, key, existingChildren) {
      let fiber;
      if (!current || current.tag !== Fragment) {
          fiber = createFiberFromFragment(elements, key);
      }
      else {
          existingChildren.delete(key);
          fiber = useFiber(current, elements);
      }
      fiber.return = returnFiber;
      return fiber;
  }
  const reconcileChildFibers = ChildReconciler(true);
  const mountChildFibers = ChildReconciler(false);

  function renderWithHooks(wip, lane) {
      // 重置 hook 相关状态，确保每次渲染都从干净的状态开始
      wip.memoizedState = null;
      wip.updateQueue = null;
      wip.alternate; // 获取备用节点
      const Component = wip.type; // 获取组件类型
      const props = wip.pendingProps; // 获取待处理的属性
      // 确保在组件执行期间，currentDispatcher.current 不会被重置
      const safeComponentCall = () => {
          return Component(props);
      };
      const children = safeComponentCall(); // 调用组件函数获取子节点
      return children;
  }

  //递归中的递阶段
  const beginWork = (wip, renderLane) => {
      //比较，返回子fiberNode
      switch (wip.tag) {
          case HostRoot:
              return updateHostRoot(wip, renderLane); // 更新根节点
          case HostComponent:
              return updateHostComponent(wip); // 更新组件节点
          case HostText:
              return null;
          case FunctionComponent:
              return updateFunctionComponent(wip);
          case Fragment:
              return updateFragment(wip);
          default:
              {
                  console.warn('beginWork未实现的类型');
              }
              break;
      }
      return null;
  };
  function updateFunctionComponent(wip, renderLane) {
      const nextChildren = renderWithHooks(wip); // 使用钩子渲染组件
      reconcileChildren(wip, nextChildren); // 递归处理子节点
      return wip.child; // 返回子节点
  }
  function updateHostRoot(wip, renderLane) {
      const baseState = wip.memoizedState; // 获取基础状态
      const updateQueue = wip.updateQueue; // 获取更新队列
      const pending = updateQueue.shared.pending; // 获取待处理的更新
      updateQueue.shared.pending = null; // 清空待处理的更新
      const { memoizedState } = processUpdateQueue(baseState, pending, renderLane); // 处理更新队列
      wip.memoizedState = memoizedState; // 更新已处理状态
      const nextChildren = wip.memoizedState; // 获取待处理的子节点
      // 确保 nextChildren 不为 null，如果为 null 则使用空数组
      const children = nextChildren !== null ? nextChildren : [];
      reconcileChildren(wip, children); // 递归处理子节点
      return wip.child; // 返回子节点
  }
  function updateFragment(wip) {
      const nextChildren = wip.pendingProps; // 获取待处理的子节点
      reconcileChildren(wip, nextChildren); // 递归处理子节点
      return wip.child; // 返回子节点
  }
  function updateHostComponent(wip) {
      const nextProps = wip.pendingProps; // 获取待处理的属性
      const nextChildren = nextProps.children; // 获取待处理的属性
      reconcileChildren(wip, nextChildren); // 递归处理子节点
      return wip.child; // 返回子节点
  }
  function reconcileChildren(wip, children) {
      const current = wip.alternate; // 获取备用节点
      if (current !== null) {
          //update
          wip.child = reconcileChildFibers(wip, current?.child, children); // 更新子节点
      }
      else {
          wip.child = mountChildFibers(wip, null, children); // 创建新的子节点
      }
  }

  let nextEffect = null;
  const commitEffects = (phrase, mask, callback) => {
      return (finishedWork, root) => {
          nextEffect = finishedWork;
          while (nextEffect !== null) {
              // 向下遍历
              const child = nextEffect.child;
              if ((nextEffect.subtreeFlags & (MutationMask | PassiveEffect)) !== NoFlags && child !== null) {
                  nextEffect = child;
              }
              else {
                  // 向上遍历 DFS
                  up: while (nextEffect !== null) {
                      callback(nextEffect, root);
                      const sibling = nextEffect.sibling;
                      if (sibling !== null) {
                          nextEffect = sibling;
                          break up;
                      }
                      nextEffect = nextEffect.return;
                  }
              }
          }
      };
  };
  const commitMutationEffectsOnFiber = (finishedWork, root) => {
      const { flags, tag } = finishedWork;
      finishedWork.alternate;
      if ((flags & Placement) !== NoFlags) {
          commitPlacement(finishedWork);
          finishedWork.flags &= ~Placement;
      }
      if ((flags & Update) !== NoFlags) {
          commitUpdate(finishedWork);
          finishedWork.flags &= ~Update;
      }
      if ((flags & ChildDeletion) !== NoFlags) {
          const deletions = finishedWork.deletions;
          if (deletions !== null) {
              deletions.forEach((childToDelete) => {
                  commitDeletion(childToDelete, root);
              });
          }
          finishedWork.flags &= ~ChildDeletion;
      }
      if ((flags & PassiveEffect) !== NoFlags) {
          // 收集回调
          commitPassiveEffect(finishedWork, root, 'update');
          finishedWork.flags &= ~PassiveEffect;
      }
  };
  const commitLayoutEffectsOnFiber = (finishedWork, root) => {
      const { flags, tag } = finishedWork;
      if ((flags & PassiveEffect) !== NoFlags) {
          // 收集回调
          commitPassiveEffect(finishedWork, root, 'update');
          finishedWork.flags &= ~PassiveEffect;
      }
  };
  const commitMutationEffects = commitEffects('mutation', MutationMask, commitMutationEffectsOnFiber);
  const commitLayoutEffects = commitEffects('layout', MutationMask, commitLayoutEffectsOnFiber);
  function commitPassiveEffect(fiber, root, type) {
      if (fiber.tag !== FunctionComponent ||
          (type === 'update' && (fiber.flags & PassiveEffect) === NoFlags)) {
          return;
      }
      const updateQueue = fiber.updateQueue;
      if (updateQueue !== null && updateQueue.lastEffect !== null) {
          if (type === 'unmount') {
              // 对于unmount类型，推入整个effect链表
              if (updateQueue.lastEffect !== null) {
                  // 遍历整个effect链表，推入所有effects
                  const lastEffect = updateQueue.lastEffect;
                  const firstEffect = lastEffect.next;
                  if (firstEffect !== null) {
                      let effect = firstEffect;
                      do {
                          root.pendingPassiveEffects.unmount.push(effect);
                          effect = effect.next;
                      } while (effect !== firstEffect);
                  }
              }
          }
          else if (type === 'update') {
              // 对于update类型，检查是否有需要执行的effects
              const lastEffect = updateQueue.lastEffect;
              const firstEffect = lastEffect.next;
              if (firstEffect !== null) {
                  let hasEffectToExecute = false;
                  let effect = firstEffect;
                  do {
                      if ((effect.tag & HookHasEffect) !== NoFlags) {
                          hasEffectToExecute = true;
                          break;
                      }
                      const nextEffect = effect.next;
                      if (nextEffect !== null) {
                          effect = nextEffect;
                      }
                      else {
                          break;
                      }
                  } while (effect !== firstEffect);
                  // 只有当有需要执行的effect时，才推入lastEffect
                  if (hasEffectToExecute) {
                      root.pendingPassiveEffects.update.push(lastEffect);
                  }
              }
          }
      }
  }
  function recordHostChildrenToDelete(childrenToDelete, unmountFiber) {
      // 1. 找到第一个root host节点
      const lastOne = childrenToDelete[childrenToDelete.length - 1];
      if (!lastOne) {
          childrenToDelete.push(unmountFiber);
      }
      else {
          let node = lastOne.sibling;
          while (node !== null) {
              if (unmountFiber === node) {
                  childrenToDelete.push(unmountFiber);
              }
              node = node.sibling;
          }
      }
  }
  function commitDeletion(childToDelete, root) {
      const rootChildrenToDelete = [];
      // 递归子树
      commitNestedComponent(childToDelete, (unmountFiber) => {
          switch (unmountFiber.tag) {
              case HostComponent:
                  recordHostChildrenToDelete(rootChildrenToDelete, unmountFiber);
                  return;
              case HostText:
                  recordHostChildrenToDelete(rootChildrenToDelete, unmountFiber);
                  return;
              case FunctionComponent:
                  commitPassiveEffect(unmountFiber, root, 'unmount');
                  return;
              default:
                  {
                      console.warn('未处理的unmount类型', unmountFiber);
                  }
          }
      });
      // 移除rootHostComponent的DOM
      if (rootChildrenToDelete.length) {
          const hostParent = getHostParent(childToDelete);
          if (hostParent !== null) {
              rootChildrenToDelete.forEach((node) => {
                  removeChild(node.stateNode, hostParent);
              });
          }
      }
      childToDelete.return = null;
      childToDelete.child = null;
  }
  function commitNestedComponent(root, onCommitUnmount) {
      let node = root;
      while (true) {
          onCommitUnmount(node);
          if (node.child !== null) {
              // 向下遍历
              node.child.return = node;
              node = node.child;
              continue;
          }
          if (node === root) {
              // 终止条件
              return;
          }
          while (node.sibling === null) {
              if (node.return === null || node.return === root) {
                  return;
              }
              // 向上归
              node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
      }
  }
  const commitPlacement = (finishedWork) => {
      {
          console.warn('执行Placement操作', finishedWork);
      }
      // parent DOM
      const hostParent = getHostParent(finishedWork);
      // host sibling
      const sibling = getHostSibling(finishedWork);
      // finishedWork ~~ DOM append parent DOM
      if (hostParent !== null) {
          insertOrAppendPlacementNodeIntoContainer(finishedWork, hostParent, sibling);
      }
  };
  function getHostSibling(fiber) {
      let node = fiber;
      findSibling: while (true) {
          while (node.sibling === null) {
              const parent = node.return;
              if (parent === null ||
                  parent.tag === HostComponent ||
                  parent.tag === HostRoot) {
                  return null;
              }
              node = parent;
          }
          node.sibling.return = node.return;
          node = node.sibling;
          while (node.tag !== HostText && node.tag !== HostComponent) {
              // 向下遍历
              if ((node.flags & Placement) !== NoFlags) {
                  continue findSibling;
              }
              if (node.child === null) {
                  continue findSibling;
              }
              else {
                  node.child.return = node.child;
                  node = node.child;
              }
          }
          if ((node.flags & Placement) === NoFlags) {
              return node.stateNode;
          }
      }
  }
  function getHostParent(fiber) {
      let parent = fiber.return;
      while (parent) {
          const parentTag = parent.tag;
          // HostComponent HostRoot
          if (parentTag === HostComponent) {
              return parent.stateNode;
          }
          if (parentTag === HostRoot) {
              return parent.stateNode.container;
          }
          parent = parent.return;
      }
      {
          console.warn('未找到host parent');
      }
      return null;
  }
  function insertOrAppendPlacementNodeIntoContainer(finishedWork, hostParent, before) {
      // fiber host
      if (finishedWork.tag === HostComponent || finishedWork.tag === HostText) {
          if (before) {
              insertChildToContainer(finishedWork.stateNode, hostParent, before);
          }
          else {
              appendChildToContainer(hostParent, finishedWork.stateNode);
          }
          return;
      }
      const child = finishedWork.child;
      if (child !== null) {
          insertOrAppendPlacementNodeIntoContainer(child, hostParent);
          let sibling = child.sibling;
          while (sibling !== null) {
              insertOrAppendPlacementNodeIntoContainer(sibling, hostParent);
              sibling = sibling.sibling;
          }
      }
  }
  function commitHookEffectList(flags, lastEffect, callback) {
      if (lastEffect === null) {
          return;
      }
      let effect = lastEffect.next;
      if (effect === null) {
          return;
      }
      do {
          if ((effect.tag & flags) === flags) {
              callback(effect);
          }
          effect = effect.next;
      } while (effect !== lastEffect.next);
  }
  function commitHookEffectListUnmount(flags, lastEffect) {
      commitHookEffectList(flags, lastEffect, (effect) => {
          const destroy = effect.destroy;
          if (typeof destroy === 'function') {
              destroy();
          }
          effect.tag &= ~HookHasEffect;
      });
  }
  function commitHookEffectListDestroy(flags, lastEffect) {
      commitHookEffectList(flags, lastEffect, (effect) => {
          const destroy = effect.destroy;
          if (typeof destroy === 'function') {
              destroy();
          }
      });
  }
  function commitHookEffectListCreate(flags, lastEffect) {
      commitHookEffectList(flags, lastEffect, (effect) => {
          const create = effect.create;
          if (typeof create === 'function') {
              const result = create();
              effect.destroy = result || undefined;
          }
      });
  }

  let syncTaskQueue = null;
  let isFlushingSyncTaskQueue = false;
  function scheduleSyncCallback(callback) {
      if (syncTaskQueue === null) {
          syncTaskQueue = [callback];
      }
      else {
          syncTaskQueue.push(callback);
      }
  }
  function flushSyncTaskQueue() {
      if (!isFlushingSyncTaskQueue && syncTaskQueue) {
          isFlushingSyncTaskQueue = true;
          try {
              syncTaskQueue.forEach(callback => callback());
          }
          catch (error) {
              {
                  console.error('flushSyncTaskQueue error', error);
              }
          }
          finally {
              isFlushingSyncTaskQueue = false;
              syncTaskQueue = null;
          }
      }
  }

  let workInProgress = null;
  let wipRootRenderLane = NoLane;
  let rootDoesHasPassiveEffect = false;
  const RootCompleted = 2;
  const RootInProgress = 3;
  function markRootUpdated(root, lane) {
      root.pendingLanes = mergeLanes(root.pendingLanes, lane);
  }
  function prepareFreshStack(root, lane) {
      root.finishedLane = NoLane;
      root.finishedWork = null;
      workInProgress = createWorkInProgress(root.current, {}); // 设置当前工作中的Fiber节点
      wipRootRenderLane = lane;
  }
  function scheduleUpdateOnFiber(fiber, lane) {
      //调度功能
      const root = markUpdateFromFiberToRoot(fiber); // 标记从Fiber节点到根节点的更新
      markRootUpdated(root, lane);
      ensureRootIsScheduled(root); // 渲染根节点
  }
  function ensureRootIsScheduled(root) {
      const updateLane = getHighestPriorityLane(root.pendingLanes);
      const exitingCallback = root.callbackNode;
      if (updateLane === NoLane) {
          if (exitingCallback !== null) {
              Scheduler.unstable_cancelCallback(exitingCallback);
          }
          root.callbackNode = null;
          root.callbackPriority = NoLane;
          return;
      }
      const curPriority = updateLane;
      const prevPriority = root.callbackPriority;
      if (prevPriority === curPriority) {
          return;
      }
      if (exitingCallback !== null) {
          Scheduler.unstable_cancelCallback(exitingCallback);
      }
      let newCallbackNode = null;
      if (updateLane === SyncLane) {
          {
              console.log(`在微任务中调度，优先级：${updateLane}`);
          }
          scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root, updateLane));
          scheduleMicroTask(flushSyncTaskQueue);
      }
      else {
          const schedulerPriority = lanesToSchedulerPriority(updateLane);
          newCallbackNode = Scheduler.unstable_scheduleCallback(schedulerPriority, performConcurrentWorkOnRoot.bind(null, root));
      }
      root.callbackNode = newCallbackNode;
      root.callbackPriority = curPriority;
  }
  function performConcurrentWorkOnRoot(root, didTimeOut) {
      //保证useEffect回调被执行
      const curCallback = root.callbackNode;
      const didFlushPassiveEffect = flushPassiveEffects(root.pendingPassiveEffects);
      if (didFlushPassiveEffect) {
          if (root.callbackNode !== curCallback) {
              return null;
          }
      }
      const lane = getHighestPriorityLane(root.pendingLanes);
      const curCallbackNode = root.callbackNode;
      if (lane === NoLane) {
          ensureRootIsScheduled(root);
          return null;
      }
      const needSync = lane === SyncLane || didTimeOut;
      //render阶段
      const exitStatus = renderRoot(root, lane, !needSync);
      ensureRootIsScheduled(root);
      if (exitStatus === RootInProgress) {
          if (root.callbackNode !== curCallbackNode) {
              return null;
          }
          return performSyncWorkOnRoot.bind(null, root);
      }
      if (exitStatus === RootCompleted) {
          const finishedWork = root.current.alternate;
          root.finishedWork = finishedWork;
          root.finishedLane = lane;
          wipRootRenderLane = NoLane;
          commitRoot(root);
      }
      else {
          console.error('还有未实现的并发更新结束状态');
      }
      return null;
  }
  function renderRoot(root, lane, shouldTimeSlice) {
      {
          console.log(`开始 ${shouldTimeSlice ? "并发" : "同步"}更新`, root);
      }
      if (wipRootRenderLane !== lane) {
          prepareFreshStack(root, lane);
      }
      do {
          try {
              shouldTimeSlice ? workLoopConcurrent() : workLoopSync();
              break; // 如果工作循环完成，跳出循环
          }
          catch (error) {
              // 处理错误逻辑，例如记录错误或重置工作状态
              {
                  console.error('workLoopSync发生错误:', error);
              }
              workInProgress = null; // 重置当前工作中的Fiber节点
          }
      } while (true);
      //终端执行 || render阶段执行完
      if (shouldTimeSlice && workInProgress !== null) {
          return RootInProgress;
      }
      if (!shouldTimeSlice && workInProgress !== null && true) {
          console.error('render阶段未完成，但workInProgress为null');
      }
      return RootCompleted;
  }
  function markUpdateFromFiberToRoot(fiber) {
      let node = fiber;
      let parent = fiber.return; // 获取父节点
      while (parent !== null) {
          node = parent; // 向上回溯到根节点
          parent = parent.return; // 获取父节点
      }
      if (node.tag === HostRoot) { // 如果根节点是HostRoot类型
          return node.stateNode; // 返回根节点的状态节点
      }
      return null; // 如果没有找到根节点，返回null
  }
  function performSyncWorkOnRoot(root, lane) {
      const nextLane = getHighestPriorityLane(root.pendingLanes);
      if (nextLane !== SyncLane) {
          ensureRootIsScheduled(root);
          return;
      }
      prepareFreshStack(root, lane);
      if (workInProgress === null) {
          {
              console.warn('workInProgress 为 null，跳过渲染');
          }
          return;
      }
      const exitStatus = renderRoot(root, nextLane, false);
      if (exitStatus === RootCompleted) {
          const finishedWork = root.current.alternate;
          root.finishedWork = finishedWork; // 设置完成的工作节点
          root.finishedLane = nextLane;
          wipRootRenderLane = NoLane;
      }
      else {
          console.error('render阶段未完成，但workInProgress为null');
      }
      commitRoot(root); // 提交根节点
  }
  function commitRoot(root) {
      const finishedWork = root.finishedWork;
      if (finishedWork === null) {
          return; // 如果没有完成的工作节点，直接返回
      }
      {
          console.warn('commit阶段开始', finishedWork);
      }
      const lane = root.finishedLane;
      if (lane === NoLane && true) {
          console.error('commit阶段finishedlane不应该为NoLane');
      }
      //重置
      root.finishedWork = null;
      root.finishedLane = NoLane;
      // 清除已完成的 lane，防止重复调度
      if (lane !== NoLane) {
          markRootFinished(root, lane);
      }
      //判断是否存在3个子阶段需要执行的操作
      const subtreeFlags = (finishedWork.subtreeFlags & (MutationMask | PassiveMask)) !== NoFlags; // 检查子树标记是否包含变更标记
      const rootHasEffect = (finishedWork.flags & (MutationMask | PassiveMask)) !== NoFlags; // 检查根节点是否有副作用标记
      if (subtreeFlags || rootHasEffect) {
          //beforeMutation
          //mutation Placement
          commitMutationEffects(finishedWork, root);
          root.current = finishedWork; // 更新当前节点为完成的工作节点
          //layout
          commitLayoutEffects(finishedWork, root);
      }
      else {
          root.current = finishedWork;
      }
      // 在mutation effects执行完后，检查是否需要调度passive effects
      if ((finishedWork.flags & PassiveMask) !== NoFlags
          || (finishedWork.subtreeFlags & PassiveMask) !== NoFlags
          || root.pendingPassiveEffects.unmount.length > 0
          || root.pendingPassiveEffects.update.length > 0) {
          if (!rootDoesHasPassiveEffect) {
              rootDoesHasPassiveEffect = true;
              //调度副作用
              Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, () => {
                  //执行副作用
                  flushPassiveEffects(root.pendingPassiveEffects);
                  rootDoesHasPassiveEffect = false;
                  return;
              });
          }
      }
      ensureRootIsScheduled(root);
  }
  function workLoopSync() {
      while (workInProgress !== null) {
          // 执行工作单元
          performUnitOfWork(workInProgress);
      }
  }
  function workLoopConcurrent() {
      while (workInProgress !== null && !Scheduler.unstable_shouldYield()) {
          performUnitOfWork(workInProgress);
      }
  }
  function performUnitOfWork(fiber) {
      const next = beginWork(fiber, wipRootRenderLane);
      fiber.memoizedProps = fiber.pendingProps; // 将待处理的属性设置为已处理的属性
      if (next === null) {
          completeUnitOfWork(fiber); // 如果没有下一个工作单元，完成当前工作单元
      }
      else {
          workInProgress = next; // 设置下一个工作单元为当前工作中的Fiber节点
      }
  }
  function flushPassiveEffects(pendingPassiveEffects) {
      let didFlushPassiveEffect = false;
      pendingPassiveEffects.unmount.forEach((effect) => {
          didFlushPassiveEffect = true;
          commitHookEffectListUnmount(PassiveEffect, effect);
      });
      pendingPassiveEffects.unmount = [];
      pendingPassiveEffects.update.forEach((effect) => {
          didFlushPassiveEffect = true;
          commitHookEffectListDestroy(PassiveEffect | HookHasEffect, effect);
      });
      pendingPassiveEffects.update.forEach((effect) => {
          didFlushPassiveEffect = true;
          commitHookEffectListCreate(PassiveEffect | HookHasEffect, effect);
      });
      pendingPassiveEffects.update = [];
      flushSyncTaskQueue();
      return didFlushPassiveEffect;
  }
  function completeUnitOfWork(fiber) {
      let node = fiber;
      do {
          completeWork(node); // 完成当前工作单元
          const sibling = node.sibling; // 获取兄弟节点
          if (sibling !== null) {
              workInProgress = sibling; // 如果有兄弟节点，设置为当前工作中的Fiber节点
              return; // 结束当前工作单元的处理
          }
          node = node.return; // 向上回溯到父节点
          workInProgress = node; // 更新当前工作中的Fiber节点
      } while (node !== null);
  }

  function createContainer(container) {
      const hostRootFiber = new FiberNode(HostRoot, {}, null); // 创建根Fiber节点
      const root = new FiberRootNode(container, hostRootFiber); // 创建Fiber根节点
      hostRootFiber.updateQueue = createUpdateQueue(); // 初始化更新队列
      hostRootFiber.memoizedState = null; // 初始化memoizedState为null
      return root;
  }
  function updateContainer(element, root) {
      const hostRootFiber = root.current; // 获取当前的根Fiber节点
      const lane = requestUpdateLane();
      const update = createUpdate(element, lane); // 创建更新
      enqueueUpdate((hostRootFiber.updateQueue), update); // 将更新添加到更新队列
      scheduleUpdateOnFiber(hostRootFiber, lane); // 调度更新
      return element; // 返回更新的元素
  }

  let idCounter = 0;
  function createRoot() {
      const container = {
          rootId: idCounter++,
          children: [],
      };
      function getChildren(parent) {
          if (parent) {
              return parent.children;
          }
          return null;
      }
      // @ts-ignore
      const root = createContainer(container); // 创建根容器
      function getChildrenAsJSX(root) {
          const children = childToJSX(getChildren(root));
          if (Array.isArray(children)) {
              return {
                  $$typeof: REACT_ELEMENT_TYPE,
                  type: REACT_FRAGMENT_TYPE,
                  key: null,
                  ref: null,
                  props: { children },
                  __mark: 'mgaw'
              };
          }
          return children;
      }
      function childToJSX(child) {
          if (typeof child === 'string' || typeof child === 'number') {
              return child;
          }
          if (Array.isArray(child)) {
              if (child.length === 0) {
                  return null;
              }
              if (child.length === 1) {
                  return childToJSX(child[0]);
              }
              const children = child.map(childToJSX);
              if (children.every(child => typeof child === 'string'
                  || typeof child === 'number')) {
                  return children.join('');
              }
              return children;
          }
          if (Array.isArray(child.children)) {
              const instance = child;
              const children = childToJSX(instance.children);
              const props = instance.props;
              if (children !== null) {
                  props.children = children;
              }
              return {
                  $$typeof: REACT_ELEMENT_TYPE,
                  type: instance.type,
                  key: null,
                  ref: null,
                  props,
                  __mark: 'mgaw'
              };
          }
          //TextInstance
          return child.text;
      }
      return {
          _Scheduler: Scheduler__namespace,
          render(element) {
              updateContainer(element, root); // 更新容器中的内容
          },
          getChildren() {
              return getChildren(container);
          },
          getChildrenAsJSX() {
              return getChildrenAsJSX(container);
          }
      };
  }

  var reactNoopRenderer = /*#__PURE__*/Object.freeze({
    __proto__: null,
    createRoot: createRoot
  });

  return reactNoopRenderer;

}));
